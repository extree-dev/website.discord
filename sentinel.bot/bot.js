require('dotenv').config({ path: '../.env' });
const { PrismaClient } = require('@prisma/client');
const { Client, GatewayIntentBits, Collection, REST, Routes } = require('discord.js');
const { initializeClient, getClient } = require('./discordClient.mjs');
const express = require('express');
const fs = require('fs');
const path = require('path');

console.log('Starting Sentinel bot...');

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
console.log('Environment check:');
console.log('DISCORD_BOT_TOKEN exists:', !!process.env.DISCORD_BOT_TOKEN);
console.log('DISCORD_BOT_TOKEN length:', process.env.DISCORD_BOT_TOKEN?.length);
console.log('DISCORD_BOT_TOKEN starts with:', process.env.DISCORD_BOT_TOKEN?.substring(0, 10));
console.log('GUILD_ID:', process.env.DISCORD_GUILD_ID);
console.log('CLIENT_ID:', process.env.DISCORD_CLIENT_ID);

if (!process.env.DISCORD_BOT_TOKEN) {
    console.error(' DISCORD_BOT_TOKEN not found in .env file');
    process.exit(1);
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–ª–∏–µ–Ω—Ç —á–µ—Ä–µ–∑ –Ω–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é
const client = initializeClient();

// –ö–õ–ê–°–° –î–õ–Ø –¢–†–ï–ö–ò–ù–ì–ê –ö–û–ú–ê–ù–î
class CommandTracker {
    constructor() {
        this.commandStats = new Map();
        this.startTime = Date.now();
        this.prisma = new PrismaClient();
    }

    async recordCommand(commandName, success, responseTime, guildId, userId, error = null) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
        if (!guildId || !userId) {
            console.log('Missing guildId or userId for command tracking');
            return;
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ø–∞–º—è—Ç—å –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
        if (!this.commandStats.has(commandName)) {
            this.commandStats.set(commandName, {
                usage: 0,
                success: 0,
                totalResponseTime: 0,
                lastUsed: Date.now(),
                type: this.getCommandType(commandName)
            });
        }

        const stats = this.commandStats.get(commandName);
        stats.usage++;
        stats.totalResponseTime += responseTime;
        if (success) stats.success++;
        stats.lastUsed = Date.now();

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É —á–µ—Ä–µ–∑ Prisma
        try {
            await this.prisma.commandStats.create({
                data: {
                    command: commandName,
                    guildId: guildId,        // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ
                    userId: userId,          // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ
                    success: success,
                    executionTime: responseTime,
                    error: error,
                    timestamp: new Date()
                }
            });
            console.log(`Saved to DB: ${commandName}, guild: ${guildId}, user: ${userId}`);
        } catch (dbError) {
            console.error(' Error saving command stats to DB:', dbError.message);
        }

        console.log(`Command tracked: ${commandName}, success: ${success}, time: ${responseTime}ms`);
    }

    getCommandType(commandName) {
        const moderationCommands = ['ban', 'mute', 'warn', 'kick', 'timeout', 'lock', 'unlock', 'clear', 'slowmode'];
        const utilityCommands = ['userinfo', 'serverinfo', 'avatar', 'help', 'ping', 'stats', 'banner'];

        if (moderationCommands.some(cmd => commandName.includes(cmd))) return 'moderation';
        if (utilityCommands.some(cmd => commandName.includes(cmd))) return 'utility';
        return 'other';
    }

    getStats(period = '24h', filter = 'all') {
        const stats = [];
        const now = Date.now();

        const periodMs = {
            '24h': 24 * 60 * 60 * 1000,
            '7d': 7 * 24 * 60 * 60 * 1000,
            '30d': 30 * 24 * 60 * 60 * 1000
        }[period] || 24 * 60 * 60 * 1000;

        for (const [commandName, data] of this.commandStats) {
            if (data.lastUsed < now - periodMs) continue;
            if (filter !== 'all' && data.type !== filter) continue;

            const successRate = data.usage > 0 ? Math.round((data.success / data.usage) * 100) : 0;
            const avgResponseTime = data.usage > 0 ? Math.round(data.totalResponseTime / data.usage) : 0;

            stats.push({
                name: commandName,
                usage: data.usage,
                success: data.success,
                successRate: successRate,
                avgResponseTime: avgResponseTime,
                type: data.type,
                lastUsed: this.formatTimeAgo(data.lastUsed)
            });
        }

        stats.sort((a, b) => b.usage - a.usage);
        return stats;
    }

    formatTimeAgo(timestamp) {
        const diff = Date.now() - timestamp;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
        if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        return 'just now';
    }

    getTotalStats() {
        let totalUsage = 0;
        let totalSuccess = 0;
        let totalResponseTime = 0;

        for (const [_, data] of this.commandStats) {
            totalUsage += data.usage;
            totalSuccess += data.success;
            totalResponseTime += data.totalResponseTime;
        }

        const overallSuccessRate = totalUsage > 0 ? Math.round((totalSuccess / totalUsage) * 100) : 0;
        const avgResponse = totalUsage > 0 ? Math.round(totalResponseTime / totalUsage) : 0;

        return {
            totalUsage,
            overallSuccessRate,
            avgResponse,
            uniqueCommands: this.commandStats.size
        };
    }
}

// –î–æ–±–∞–≤–ª—è–µ–º –≤ bot.js –∫–ª–∞—Å—Å –¥–ª—è —Å–±–æ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
class StatsCollector {
    constructor() {
        this.memberHistory = new Map();
        this.startTime = Date.now();
        this.prisma = new PrismaClient();
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
    async saveServerStats(guild) {
        try {
            const totalMembers = guild.memberCount;

            // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–Ω–ª–∞–π–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            await guild.members.fetch();
            const onlineMembers = guild.members.cache.filter(member =>
                member.presence?.status === 'online' ||
                member.presence?.status === 'idle' ||
                member.presence?.status === 'dnd'
            ).size;

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
            await this.prisma.serverStats.create({
                data: {
                    guildId: guild.id,
                    memberCount: totalMembers,
                    onlineCount: onlineMembers,
                    timestamp: new Date()
                }
            });

            console.log(`REAL STATS: ${totalMembers} members, ${onlineMembers} online`);

        } catch (error) {
            console.error('Error saving server stats:', error);
        }
    }

    // –†–∞—Å—á–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞
    calculateRealGrowth(currentStats, previousStats) {
        if (!previousStats || previousStats.memberCount === 0) {
            return { change: 0, isPositive: true, period: 'new' };
        }

        const change = ((currentStats.memberCount - previousStats.memberCount) / previousStats.memberCount) * 100;
        const isPositive = change >= 0;

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–∏–æ–¥ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞–∑–Ω–∏—Ü—ã –≤–æ –≤—Ä–µ–º–µ–Ω–∏
        const timeDiff = currentStats.timestamp - previousStats.timestamp;
        const hoursDiff = timeDiff / (1000 * 60 * 60);

        let period = 'recently';
        if (hoursDiff >= 24) period = 'yesterday';
        if (hoursDiff >= 168) period = 'last week';

        return {
            change: Math.round(change * 10) / 10,
            isPositive,
            period,
            actualChange: currentStats.memberCount - previousStats.memberCount
        };
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
    async getLatestStats(guildId) {
        try {
            const stats = await this.prisma.serverStats.findMany({
                where: { guildId },
                orderBy: { timestamp: 'desc' },
                take: 10
            });

            return stats.length > 0 ? stats : null;
        } catch (error) {
            console.error('Error getting latest stats:', error);
            return null;
        }
    }
}

// –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Å–±–æ—Ä—â–∏–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
global.statsCollector = new StatsCollector();

// –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π —Å–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
function startStatsCollection(client) {
    setInterval(async () => {
        try {
            const guild = client.guilds.cache.get(process.env.GUILD_ID);
            if (guild) {
                await global.statsCollector.saveServerStats(guild);
            }
        } catch (error) {
            console.error('Error in stats collection:', error);
        }
    }, 5 * 60 * 1000); // –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
}

// –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –±–æ—Ç–∞
client.once('ready', () => {
    console.log('üîÑ Starting stats collection...');
    startStatsCollection(client);

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    const guild = client.guilds.cache.get(process.env.GUILD_ID);
    if (guild) {
        global.statsCollector.saveServerStats(guild);
    }
});

// –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫–µ—Ä
global.commandTracker = new CommandTracker();

// –ö–æ–ª–ª–µ–∫—Ü–∏—è –¥–ª—è –∫–æ–º–∞–Ω–¥
client.commands = new Collection();

// –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–º–∞–Ω–¥—ã
const commandsPath = path.join(__dirname, 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = require(filePath);

    if ('data' in command && 'execute' in command) {
        client.commands.set(command.data.name, command);
        console.log(`Loaded command: /${command.data.name}`);
    } else {
        console.log(`Command ${filePath} is missing required properties`);
    }
}

// –§–£–ù–ö–¶–ò–Ø –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ô –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò –ö–û–ú–ê–ù–î
async function registerCommands() {
    try {
        const commands = [];

        for (const file of commandFiles) {
            const filePath = path.join(commandsPath, file);
            const command = require(filePath);
            if ('data' in command && 'execute' in command) {
                commands.push(command.data.toJSON());
            }
        }

        console.log(` Starting automatic command registration for ${commands.length} commands...`);

        const rest = new REST().setToken(process.env.DISCORD_BOT_TOKEN);

        // 1. –°–Ω–∞—á–∞–ª–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –≥–∏–ª—å–¥–∏–∏ (—Å–µ—Ä–≤–µ—Ä–∞)
        try {
            console.log('üè† Registering guild commands...');
            const guildData = await rest.put(
                Routes.applicationGuildCommands(
                    process.env.CLIENT_ID || process.env.DISCORD_CLIENT_ID,
                    process.env.GUILD_ID || process.env.DISCORD_GUILD_ID
                ),
                { body: commands }
            );
            console.log(` Successfully registered ${guildData.length} guild commands.`);
            guildData.forEach(cmd => console.log(`   - /${cmd.name}`));
        } catch (guildError) {
            console.log(' Guild command registration failed:', guildError.message);
        }

        // 2. –ó–∞—Ç–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ì–õ–û–ë–ê–õ–¨–ù–´–ï –∫–æ–º–∞–Ω–¥—ã (–¥–ª—è –∑–Ω–∞—á–∫–∞)
        try {
            console.log(' Registering GLOBAL commands for badge...');
            const globalData = await rest.put(
                Routes.applicationCommands(process.env.CLIENT_ID || process.env.DISCORD_CLIENT_ID),
                { body: commands }
            );
            console.log(` Global commands registered successfully! ${globalData.length} commands.`);
            console.log(' Badge "Supports Slash Commands" should appear within 24 hours!');
        } catch (globalError) {
            console.log(' Global command registration failed:', globalError.message);
            console.log(' This may affect the badge appearance, but bot will continue working.');
        }

    } catch (error) {
        console.error(' Error during command registration:', error);
        console.log(' But continuing bot startup...');
    }
}

// –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
const eventsPath = path.join(__dirname, 'events');
const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));

for (const file of eventFiles) {
    const filePath = path.join(eventsPath, file);
    const event = require(filePath);

    if (event.once) {
        client.once(event.name, (...args) => event.execute(...args));
    } else {
        client.on(event.name, (...args) => event.execute(...args));
    }

    console.log(`Loaded event: ${event.name}`);
}

// –ó–∞–ø—É—Å–∫–∞–µ–º API
const { startAPI } = require('./api.js');
startAPI();

// –ü—Ä–æ–±—É–µ–º –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–æ—Ç—É
console.log('Attempting to login to Discord...');
client.login(process.env.DISCORD_BOT_TOKEN)
    .then(() => {
        console.log('Bot logged in successfully');

        // –ó–ê–ü–£–°–ö–ê–ï–ú –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–£–Æ –†–ï–ì–ò–°–¢–†–ê–¶–ò–Æ –ü–û–°–õ–ï –£–°–ü–ï–®–ù–û–ì–û –õ–û–ì–ò–ù–ê
        registerCommands();
    })
    .catch(error => {
        console.error('Bot login failed:', error.message);
        console.log('But API is still running!');
    });

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('Shutting down...');
    const finalStats = global.commandTracker.getTotalStats();
    console.log(`Final stats: ${finalStats.totalUsage} commands tracked`);
    client.destroy();
    process.exit(0);
});